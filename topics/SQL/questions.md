
- Как использовать CASE, GROUP BY с агрегирующими функциями (MIN, MAX, AVG и т.д.)?



## Порядок операторов

- написание:
  
1. SELECT
2. FROM/JOIN
3. WHERE
4. GROUP BY
5. HAVING
6. ORDER BY
7. LIMIT
  
- выполнение:

1. FROM/JOIN: определение данных.
2. WHERE: фильтрация записей.
3. GROUP BY: группировка данных.
4. HAVING: отбор нужных данных.
5. SELECT: получение всех нужных столбцов и выражений.
6. ORDER BY: сортировка полученных значений.
7. LIMIT: ограничение количества строк.

## JOIN

Есть отдельный разбор здесь: [Виды JOIN. Пример в PostgreSQL](https://github.com/Malakhova-Natalya/My_open_textbook/blob/main/topics/SQL/JOIN.md)

## Виды связей в таблицах

- **Один к одному (1:1)** — это отношение, при котором каждая запись в одной таблице связана только с одной записью в другой таблице.

Например, условная таблица «Мама» и таблица «Ребёнок» связаны отношением один к одному, если у одной мамы один ребёнок.

- **Один ко многим (1:M)** — это отношение, при котором одна запись в главной таблице может быть связана с несколькими записями в подчинённой таблице. 

Например, условная таблица «Мама» и таблица «Дети» связаны отношением один ко многим, если у одной мамы несколько детей. 

- **Многие ко многим (M:N)** — это отношение, при котором одна запись в главной таблице может быть связана с несколькими записями в подчинённой таблице, и наоборот.

Например, условная таблица «Родители» и таблица «Дети» связаны отношением один ко многим, если в семье есть и папа, и мама, и несколько детей. 

## Виды ключей для связи таблиц

- **Первичный ключ (Primary Key)** — уникальное значение, которое связывает запись в таблице и обеспечивает целостность данных. Может быть только один такой ключ на таблицу, и его значения не могут быть пустыми.
  
- **Составной ключ (Composite Key)** — разновидность первичного ключа, состоящая из нескольких столбцов, комбинация значений которых обеспечивает уникальность записи.

- **Внешний ключ (Foreign Key)** — связывает записи в одной таблице с записями в другой через общее поле, которое является первичным ключом в другой таблице.

## Таблицы фактов и измерений

**Таблица фактов** — это центральная таблица в схеме «звезда» или «снежинка» в хранилище данных, которая содержит ключевые факты или показатели бизнес-процессов и деятельности. Она состоит из числовых типов данных и внешних ключей, связанных со связанными измерениями. Таблицы фактов используются для анализа производительности и функциональных возможностей.

**Таблица измерений** представляет собой таблицу, содержащую атрибуты, связанные с собранными данными. Она предоставляет различные точки зрения и атрибуты, относящиеся к ключевым фактам в таблице фактов. Измерения помогают аналитикам получать значимую информацию для поддержки принятия решений и бизнес-аналитики.

## Нормализация

**Нормализация** — это метод проектирования реляционных баз данных, направленный на создание структуры с чётким представлением информации, взаимосвязей и отсутствием избыточности и потери данных. Нормализация включает разделение больших таблиц на меньшие логические единицы с использованием ключей и функциональных зависимостей. Этот процесс помогает разработчикам баз данных оптимально распределять атрибуты по таблицам, избегать избыточности данных, повышать эффективность использования памяти сервера и обеспечивать максимальную целостность данных.

## Степени нормализации

**Существуют пять степеней нормализации данных**:
1. Первая нормальная форма (1НФ) — таблица не содержит повторяющихся групп или повторяющихся столбцов для одного значения ключа.
2. Вторая нормальная форма (2НФ) — таблица находится в 1НФ и все её неключевые столбцы полностью функционально зависят от первичного ключа.
3. Третья нормальная форма (3НФ) — таблица находится в 2НФ, и все её неключевые столбцы не зависят транзитивно от первичного ключа.
4. Нормальная форма Бойса-Кодда (BCNF) — таблица находится в 3НФ, и каждый определитель (набор столбцов, который однозначно определяет другие столбцы) является потенциальным ключом.
5. Пятая нормальная форма (5НФ) — таблица находится в BCNF и не имеет многозначных зависимостей.

## 1НФ
Таблица с заказами в 1НФ может выглядеть следующим образом:

| Номер заказа | Дата заказа	| Клиент	| Товар	| Количество	| Цена |
| :--------------------: | :---------------------: |:---------------------------:| :--------------------: | :---------------------: |:---------------------------:|
| 1	| 20.08.2023	| Иванов	| Книга	| 1	| 100 |
| 2	| 21.08.2023	| Петров	| Ручка	| 2	| 50 |
| 3	| 22.08.2023	| Сидоров	| Карандаш	| 3	| 30 |

В этой таблице каждый заказ представлен отдельной строкой, и каждый столбец содержит одно значение, относящееся к конкретному заказу.

## 2НФ

Таблица с заказами в 2НФ может выглядеть так:

| Номер заказа | Дата заказа	| Клиент	| 
| :--------------------: | :---------------------: |:---------------------------:|
| 1	| 20.08.2023	| Иванов	|
| 2	| 21.08.2023	| Петров	|
| 3	| 22.08.2023	| Сидоров	|

В этой таблице каждый заказ представлен отдельной строкой, и каждый столбец содержит одно значение, относящееся к конкретному заказу. Неключевые атрибуты (дата заказа и клиент) зависят от первичного ключа (номера заказа).

## 3НФ

Таблица с заказами в 3НФ может выглядеть следующим образом:

| Номер заказа | Дата заказа	| Клиент	| 
| :--------------------: | :---------------------: |:---------------------------:|
| 1	| 20.08.2023	| Иванов	|
| 2	| 21.08.2023	| Петров	|
| 3	| 22.08.2023	| Сидоров	|

В этой таблице каждый заказ представлен отдельной строкой, и каждый столбец содержит одно значение, относящееся к конкретному заказу. Неключевые атрибуты (дата заказа и клиент) зависят только от первичного ключа (номера заказа), и между ними нет транзитивных зависимостей.

Каждый неключевой атрибут зависит только от первичного ключа и не зависит от других неключевых атрибутов. Это гарантирует, что изменения в значениях неключевых столбцов не будут влиять на другие неключевые столбцы через промежуточные зависимости.

## В чём отличие 3НФ от 2НФ

**Третья нормальная форма (3НФ)** — это одна из возможных нормальных форм отношения в реляционной базе данных. Она была сформулирована Э. Ф. Коддом в 1971 году.


Переменная отношения R находится в 3НФ тогда и только тогда, когда выполняются следующие условия:
- R находится во второй нормальной форме.
- Ни один неключевой атрибут R не находится в транзитивной функциональной зависимости от потенциального ключа R.


Рассмотрим пример. Пусть у нас есть переменная отношения R1:

| Сотрудник	| Отдел	| Телефон |
| :-----: | :-----: | :-----: |
| Гришин	| Бухгалтерия	| 11-22-33 | 
| Васильев	| Бухгалтерия	| 11-22-33 | 
| Петров	| Снабжение	| 44-55-66 | 

В этом примере атрибут «Сотрудник» является первичным ключом, а атрибуты «Отдел» и «Телефон» зависят от него. Однако функциональная зависимость «Сотрудник → Отдел» является транзитивной, так как существует функциональная зависимость «Отдел → Телефон», которая также присутствует в этой переменной отношения.

Таким образом, R1 не находится в 3НФ, так как функциональная зависимость «Сотрудник → Отдел» является транзитивной. 

Чтобы привести R1 в 3НФ, можно разделить её на две переменные отношения: R2 и R3:

| R2: Отдел	| Телефон |
| :-----: | :-----: |
| Бухгалтерия	| 11-22-33 | 
| Снабжение	| 44-55-66 | 


| R3: Сотрудник	| Отдел |
| :-----: | :-----: |
| Гришин	| Бухгалтерия | 
| Васильев	| Бухгалтерия | 
| Петров	| Снабжение | 

## CASE внутри агрегатных функций

Чтобы использовать CASE и GROUP BY с агрегирующими функциями (MIN, MAX, AVG и т. д.), выполните следующие шаги:

1. Создайте запрос с оператором SELECT, включая агрегирующую функцию и поле, по которому хотите группировать записи. Например:
 
    SELECT user_name, COUNT(user_id) 
    FROM users
    GROUP BY user_name;

2. Используйте оператор CASE внутри агрегатной функции для вычисления дополнительных значений на основе условия. Например:

    SELECT user_name, COUNT(CASE WHEN status = 'active' THEN user_id END), COUNT(user_id)
    FROM users
    GROUP BY user_name;

В этом примере мы используем оператор CASE внутри агрегатной функции COUNT для подсчёта количества пользователей с активным статусом (status = 'active').

## Виды оконных функций

Основные виды оконных функций в SQL:

 - **Агрегатные оконные функции** (SUM(), AVG(), MIN(), MAX()). Позволяют выполнять агрегатные вычисления по окну строк.

- **Ранжирующие функции** (RANK(), DENSE_RANK(), ROW_NUMBER()). Позволяют присваивать ранги строкам в пределах окна.

- **Функции смещения** (LAG(), LEAD()). Позволяют получать значения из предыдущей или следующей строки в окне.

- **Кумулятивные функции** (CUME_DIST(), PERCENT_RANK()). Позволяют вычислять кумулятивное распределение и процентильное ранжирование строк в окне.
